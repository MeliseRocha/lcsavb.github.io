---
layout: post
title: Navigating Nix
subtitle: Reproducibility is key.
date: 2023-12-15
cover-img: /images/data.webp
thumbnail-img: /images/data.webp
#share-img: /assets/img/path.jpg
#tags: [books, test]
#author: Sharon Smith and Barry Simpson
---

Today, I'm diving into Docker, Nix, and the quest for the trouble-free (or maybe BIG trouble once, yet never again. Like installing Arch Linux) project setup.

## What's Up with Nix?

First off, Nix is a powerful package manager for Linux and other Unix systems that makes package management reliable and reproducible. It provides atomic upgrades and rollbacks, side-by-side installation of multiple versions of a package, multi-user package management, and easy setup of build environments.

In other words is like that smart friend who knows exactly what your project needs to run, no matter where it's going. It's all about keeping your development and production stages looking like identical twins. 

But even smart friends can bring complexities into our lives, right?

## The quest for the base image

I initially picked NixOS (remember Nix Package Manager is one thing and the OS is another!) as the base image. But that is like using a sledgehammer for a nail when it comes to Docker images. It's a full-blown OS! Imagine packing your entire house when you just need a vacation suitcase.

Nix shines in reproducibility, but NixOS can change over time. It's like trying to freeze a river - sure, it's still water, but it's always flowing and changing.

## Alternatives to NixOS

So, I embarked on a quest for alternatives, seeking something lighter yet robust. Why not go for something more streamlined like Alpine Linux? Indeed it is way lighter, yet it is still an OS!

So, I went for the [Tiny Python Docker Image](https://github.com/CrafterKolyan/tiny-python-docker-image/blob/main/Dockerfile.scratch-full). 

``` Dockerfile
ARG PYTHON_VERSION=3.11

FROM alpine as builder
ARG PYTHON_VERSION

RUN apk add --no-cache python3~=${PYTHON_VERSION}
WORKDIR /usr/lib/python${PYTHON_VERSION}
RUN python -m compileall -o 2 .
RUN find . -name "*.cpython-*.opt-2.pyc" | awk '{print $1, $1}' | sed 's/__pycache__\///2' | sed 's/.cpython-[0-9]\{2,\}.opt-2//2' | xargs -n 2 mv
RUN find . -name "*.py" -delete
RUN find . -name "__pycache__" -exec rm -r {} +

FROM scratch
ARG PYTHON_VERSION

COPY --from=builder /usr/bin/python3 /
COPY --from=builder /lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1
COPY --from=builder /usr/lib/libpython${PYTHON_VERSION}.so.1.0 /usr/lib/libpython${PYTHON_VERSION}.so.1.0
COPY --from=builder /usr/lib/python${PYTHON_VERSION}/ /usr/lib/python${PYTHON_VERSION}/

ENTRYPOINT ["/python3"]
```
In the first stage, named "builder," it installs this specific Python version on Alpine, then compiles Python files into optimized bytecode.  This compilation step enhances performance by generating bytecode files for the Python interpreter. The script proceeds to reorganize these compiled files for efficiency, removes the original .py source files to save space, and cleans up cache directories. 

In the second phase, starting from a "scratch" image (which is essentially empty), it copies the compiled Python and necessary libraries from the "builder" stage. Therefore, the final image contains only the Python and its direct dependencies, but not a complete installation of Alpine Linux. This is done to ensure that the image is as lean as possible, containing only the essentials to run Python applications.

After building it, I pushed to docker hub.

## Using Nix to setup the application container

 Let's examine it closely. This script is more than ordinary; it serves as the foundational blueprint for my application's environment. Although achieving the same objective was possible using a Dockerfile, that approach would have resulted in a greater footprint. Moreover, the level of reproducibility attainable with Nix far surpasses what could be achieved with Docker.

Here's a sneak peek into what makes it tick:

```nix

{ pkgs ? import <nixpkgs> {} 
, pkgsLinux ? import <nixpkgs> { system = "x86_64-linux"; }
}:

let
  dockerTools = pkgs.dockerTools;

  currentDir = ./.;

  pythonTiny = dockerTools.pullImage {
    # this is the address for my python-tiny container built above
    imageName = "docker.io/lcsavb/python-tiny";
    sha256 = "sha256-lPenxSMmed8Ab+jy9en2UaMnBcCYlR1/CYOxh8M0htk=";
    imageDigest = "sha256:9d5d8fc0f7592c64c23d4028a7acc9e8a46bb5789620368cd917124f06e4eaf9";
  };

  # as pypdftk is not available through the Nix Packages, 
  # it is necessary to build it manually.
  pypdftk = pkgs.python3Packages.buildPythonPackage rec {
    pname = "pypdftk";
    version = "0.5";
    src = pkgs.python3Packages.fetchPypi {
      inherit pname version;
      sha256 = "sha256-tvfwABM0gIQrO/n4Iiy2vV4rIM9QxewFDy5E2ffcMpY";
    };
    doCheck = false;
  };

  pythonEnv = pkgs.python311.withPackages (ps: with ps; [
    django
    django_extensions
    django-crispy-forms
    django-crispy-bootstrap4
    pypdftk
  ]);
in
pkgs.dockerTools.buildImage {
  name = "ac2";
  tag = "dev";
  fromImage = pythonTiny;
  contents = [ 
    currentDir
    pythonEnv
    # bash can't be stripped out, because pdftk
    # is run on the shell to manipulate the pdfs
    pkgs.bash
    # if PDFTK from nixpkgs is used, it
    # adds 1GB to the container!!!
    # pkgs.pdftk
  ];
  config = {
    Cmd = [ "/bin/sh" "-c" "./startup.sh" ];    
    ExposedPorts = {
      "8000/tcp" = {};
    };
  };
}
```

- **Setting the Stage**: I start by importing `nixpkgs` to provide access to the [nix-repository](https://search.nixos.org/packages).
- **Crafting the Potion**: Then, I mix up a custom environment with Python, Django, and Crispy.
- **Customizing further**: pypdftk is not available in the Nix default set of 80.000 packages, so I had to build it specifically. Pypdftk provides the link between python commands to the PDF Toolkit.

- **Last but not least**: When in production, I'll add a step to compile all files like it was done in the base image.

Finally the container is build with:

``` bash
nix-build default.nix
```

And here there's a essential additional step not needed when using simply docker, load the container:

``` bash
docker load < result
```

Then the container must be run and the port exposed:

``` bash
sudo docker run -it -p 8000:8000 (container-name)
```

The total container size is 546MB before installing Pdftk from the nixpkgs. After it skyrockets to 1.5GB - this is due to the fact that it is a Java program which depends on OpenJDK and some other dependencies. I tried a different approach and modified the base image again to contain a minimal JRE environment, yet that did not reduced the image too much and I ended up in depedency hell.

So I decided to use [pre-built binaries](https://gitlab.com/pdftk-java/pdftk#pre-built-binaries) which "allegedly" don't have any dependencies. But when running from the container I got:

``` bash
bash-5.2# pdftk
bash: /usr/bin/pdftk: cannot execute: required file not found
```

So it was time to check for dynamic dependencies on run time:

``` bash
$ ldd pdftk
	linux-vdso.so.1 (0x00007fffdf5c3000)
	libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007f3c52e00000)
	libm.so.6 => /usr/lib/libm.so.6 (0x00007f3c52d13000)
	libpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007f3c5308e000)
	libdl.so.2 => /usr/lib/libdl.so.2 (0x00007f3c53089000)
	libz.so.1 => /usr/lib/libz.so.1 (0x00007f3c52cf9000)
	librt.so.1 => /usr/lib/librt.so.1 (0x00007f3c53084000)
	libc.so.6 => /usr/lib/libc.so.6 (0x00007f3c52b17000)
	/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f3c530bc000)
	libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f3c52af2000)
```

As it is evident, the documentation was wrong. That is a great example how to cook a stripped down image requires a lot of care and attention to detail. It reminded my the times I compiled my own minimal Linux Kernel specific to my computer and nothing else.

## Signing Off

Choosing the right base image in Docker isn't just a technical decision; it's a strategic move in your project's journey. While NixOS brought me wisdom in control and isolation, I've found that a lighter touch might better serve the speed and adaptability my Django project needs.

So, fellow travelers, as you navigate the seas of containerization and environment configurations, keep your eyes open for the tools and choices that best fit your journey. Share your stories and learn from each other.

Until next time, keep coding and stay curious!