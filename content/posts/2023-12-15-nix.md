---
layout: post
title: Navigating Nix
subtitle: Reproducibility is key.
date: 2023-12-15
#cover-img: /assets/img/path.jpg
#thumbnail-img: /assets/img/thumb.png
#share-img: /assets/img/path.jpg
#tags: [books, test]
#author: Sharon Smith and Barry Simpson
---

Today, I'm diving into Docker, Nix, and the quest for the trouble-free (or maybe BIG trouble once, yet never again. Like installing Arch Linux) project setup.

## What's Up with Nix?

First off, Nix is a powerful package manager for Linux and other Unix systems that makes package management reliable and reproducible. It provides atomic upgrades and rollbacks, side-by-side installation of multiple versions of a package, multi-user package management, and easy setup of build environments.

In other words is like that smart friend who knows exactly what your project needs to run, no matter where it's going. It's all about keeping your development and production stages looking like identical twins. 

But even smart friends can bring complexities into our lives, right?

## Using Nix to setup a container

 Let's examine it closely. This script is more than ordinary; it serves as the foundational blueprint for my application's environment. Although achieving the same objective was possible using a Dockerfile, that approach would have resulted in a greater footprint. Moreover, the level of reproducibility attainable with Nix far surpasses what could be achieved with Docker.

Here's a sneak peek into what makes it tick:

```nix

{ pkgs ? import <nixpkgs> {} 
, pkgsLinux ? import <nixpkgs> { system = "x86_64-linux"; }
}:

let
  dockerTools = pkgs.dockerTools;
  currentDir = ./.;
  pythonTiny = dockerTools.pullImage {
    imageName = "docker.io/lcsavb/python-tiny";
    sha256 = "sha256-lPenxSMmed8Ab+jy9en2UaMnBcCYlR1/CYOxh8M0htk=";
    imageDigest = "sha256:9d5d8fc0f7592c64c23d4028a7acc9e8a46bb5789620368cd917124f06e4eaf9";
  };

  pypdftk = pkgs.python3Packages.buildPythonPackage rec {
    pname = "pypdftk";
    version = "0.5";
    src = pkgs.python3Packages.fetchPypi {
      inherit pname version;
      sha256 = "sha256-tvfwABM0gIQrO/n4Iiy2vV4rIM9QxewFDy5E2ffcMpY";
    };
    doCheck = false;
  };

  crispyForms = pkgs.python3Packages.buildPythonApplication rec {
    pname = "django-crispy-forms";
    version = "2.1";  # use the version you need

    src = pkgs.python3Packages.fetchPypi {
      inherit pname version;
      sha256 = "sha256-TX7EMZM61NS1xabeSlhNJGE8NH25rBaHI8mq9jr0u5Y=";  # replace with the correct sha256
    };

    format = "pyproject";

    doCheck = false;
  };

  pythonEnv = pkgs.python311.withPackages (ps: [
    ps.pip
    ps.django
    ps.django_extensions
    crispyForms
    pypdftk
  ]);
in
pkgs.dockerTools.buildImage {
  name = "ac2";
  tag = "dev";
  fromImage = pythonTiny;
  contents = [ 
    currentDir
    pkgs.bash
    pythonEnv
    pkgs.pdftk
  ];
  config = {
    Cmd = [ "/bin/sh" "-c" "./startup.sh" ];    
    ExposedPorts = {
      "8000/tcp" = {};
    };
  };
}
```

- **Setting the Stage**: I start by importing goodies from `nixpkgs`, it's like opening a chest of software tools and packages.
- **Crafting the Potion**: Then, I mix up a custom environment with Python, Django, some PDF magic with pypdftk and beautiful forms with Crispy.

Finally the container is build with:

``` bash
nix-build default.nix
```

And here there's a essential additional step not needed when using simply docker, load the container:

``` bash
docker load < result
```

## The Plot Twist: NixOS as the Base Image

I initially picked NixOS (remember Nix Package Manager is one thing and the OS is another!) as the base image. But that is like using a sledgehammer for a nail when it comes to Docker images. It's a full-blown OS! Imagine packing your entire house when you just need a vacation suitcase.

Nix shines in reproducibility, but NixOS can change over time. It's like trying to freeze a river - sure, it's still water, but it's always flowing and changing.

## Rethinking the Base: Alternatives to NixOS

So, I embarked on a quest for alternatives, seeking something lighter yet robust. Why not go for something more streamlined like Alpine Linux? Indeed it is way lighter, yet it is still an OS!

So, I went for the [Tiny Python Docker Image](https://github.com/CrafterKolyan/tiny-python-docker-image/blob/main/Dockerfile.scratch-full). 

``` Dockerfile
ARG PYTHON_VERSION=3.11

FROM alpine as builder
ARG PYTHON_VERSION

RUN apk add --no-cache python3~=${PYTHON_VERSION}
WORKDIR /usr/lib/python${PYTHON_VERSION}
RUN python -m compileall -o 2 .
RUN find . -name "*.cpython-*.opt-2.pyc" | awk '{print $1, $1}' | sed 's/__pycache__\///2' | sed 's/.cpython-[0-9]\{2,\}.opt-2//2' | xargs -n 2 mv
RUN find . -name "*.py" -delete
RUN find . -name "__pycache__" -exec rm -r {} +

FROM scratch
ARG PYTHON_VERSION

COPY --from=builder /usr/bin/python3 /
COPY --from=builder /lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1
COPY --from=builder /usr/lib/libpython${PYTHON_VERSION}.so.1.0 /usr/lib/libpython${PYTHON_VERSION}.so.1.0
COPY --from=builder /usr/lib/python${PYTHON_VERSION}/ /usr/lib/python${PYTHON_VERSION}/

ENTRYPOINT ["/python3"]
```
In the first stage, named "builder," it installs this specific Python version on Alpine, then compiles Python files into optimized bytecode.  This compilation step enhances performance by generating bytecode files for the Python interpreter. The script proceeds to reorganize these compiled files for efficiency, removes the original .py source files to save space, and cleans up cache directories. 

In the second phase, starting from a "scratch" image (which is essentially empty), it copies the compiled Python and necessary libraries from the "builder" stage. Therefore, the final image contains only the Python and its direct dependencies, but not a complete installation of Alpine Linux. This is done to ensure that the image is as lean as possible, containing only the essentials to run Python applications.

After building it, I pushed to docker hub.

## Signing Off

Choosing the right base image in Docker isn't just a technical decision; it's a strategic move in your project's journey. While NixOS brought me wisdom in control and isolation, I've found that a lighter touch might better serve the speed and adaptability my Django project needs.

So, fellow travelers, as you navigate the seas of containerization and environment configurations, keep your eyes open for the tools and choices that best fit your journey. Share your stories and learn from each other.

Until next time, keep coding and stay curious!