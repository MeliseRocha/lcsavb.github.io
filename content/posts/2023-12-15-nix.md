---
layout: post
title: Navigating Nix
subtitle: Reproducibility is key.
date: 2023-12-15
cover-img: /images/data.webp
thumbnail-img: /images/data.webp
#share-img: /assets/img/path.jpg
#tags: [books, test]
#author: Sharon Smith and Barry Simpson
---

Today, I'm diving into Docker, Nix, and the quest for the trouble-free (or maybe BIG trouble once, yet never again. Like installing Arch Linux) project setup.

## What's Up with Nix?

First off, Nix is a powerful package manager for Linux and other Unix systems that makes package management reliable and reproducible. It provides atomic upgrades and rollbacks, side-by-side installation of multiple versions of a package, multi-user package management, and easy setup of build environments.

In other words is like that smart friend who knows exactly what your project needs to run, no matter where it's going. It's all about keeping your development and production stages looking like identical twins. 

But even smart friends can bring complexities into our lives, right?

## The quest for the base image

I initially picked NixOS (remember Nix Package Manager is one thing and the OS is another!) as the base image. But that is like using a sledgehammer for a nail when it comes to Docker images. It's a full-blown OS! Imagine packing your entire house when you just need a vacation suitcase.

Nix shines in reproducibility, but NixOS can change over time. It's like trying to freeze a river - sure, it's still water, but it's always flowing and changing.

## Alternatives to NixOS

So, I embarked on a quest for alternatives, seeking something lighter yet robust. Why not go for something more streamlined like Alpine Linux? Indeed it is way lighter, yet it is still an OS!

So, I went for the [Tiny Python Docker Image](https://github.com/CrafterKolyan/tiny-python-docker-image/blob/main/Dockerfile.scratch-full). 

``` Dockerfile
ARG PYTHON_VERSION=3.11

FROM alpine as builder
ARG PYTHON_VERSION

RUN apk add --no-cache python3~=${PYTHON_VERSION}
WORKDIR /usr/lib/python${PYTHON_VERSION}
RUN python -m compileall -o 2 .
RUN find . -name "*.cpython-*.opt-2.pyc" | awk '{print $1, $1}' | sed 's/__pycache__\///2' | sed 's/.cpython-[0-9]\{2,\}.opt-2//2' | xargs -n 2 mv
RUN find . -name "*.py" -delete
RUN find . -name "__pycache__" -exec rm -r {} +

FROM scratch
ARG PYTHON_VERSION

COPY --from=builder /usr/bin/python3 /
COPY --from=builder /lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1
COPY --from=builder /usr/lib/libpython${PYTHON_VERSION}.so.1.0 /usr/lib/libpython${PYTHON_VERSION}.so.1.0
COPY --from=builder /usr/lib/python${PYTHON_VERSION}/ /usr/lib/python${PYTHON_VERSION}/

ENTRYPOINT ["/python3"]
```
In the first stage, named "builder," it installs this specific Python version on Alpine, then compiles Python files into optimized bytecode.  This compilation step enhances performance by generating bytecode files for the Python interpreter. The script proceeds to reorganize these compiled files for efficiency, removes the original .py source files to save space, and cleans up cache directories. 

In the second phase, starting from a "scratch" image (which is essentially empty), it copies the compiled Python and necessary libraries from the "builder" stage. Therefore, the final image contains only the Python and its direct dependencies, but not a complete installation of Alpine Linux. This is done to ensure that the image is as lean as possible, containing only the essentials to run Python applications.

After building it, I pushed to docker hub.

## Using Nix to setup a container

 Let's examine it closely. This script is more than ordinary; it serves as the foundational blueprint for my application's environment. Although achieving the same objective was possible using a Dockerfile, that approach would have resulted in a greater footprint. Moreover, the level of reproducibility attainable with Nix far surpasses what could be achieved with Docker.

Here's a sneak peek into what makes it tick:

```nix

{ pkgs ? import <nixpkgs> {} 
, pkgsLinux ? import <nixpkgs> { system = "x86_64-linux"; }
}:

let
  dockerTools = pkgs.dockerTools;

  currentDir = ./.;

  pythonTiny = dockerTools.pullImage {
    # this is the address for my python-tiny container built above
    imageName = "docker.io/lcsavb/python-tiny";
    sha256 = "sha256-lPenxSMmed8Ab+jy9en2UaMnBcCYlR1/CYOxh8M0htk=";
    imageDigest = "sha256:9d5d8fc0f7592c64c23d4028a7acc9e8a46bb5789620368cd917124f06e4eaf9";
  };

  # as pypdftk is not available through the Nix Packages, 
  # it is necessary to build it manually.
  pypdftk = pkgs.python3Packages.buildPythonPackage rec {
    pname = "pypdftk";
    version = "0.5";
    src = pkgs.python3Packages.fetchPypi {
      inherit pname version;
      sha256 = "sha256-tvfwABM0gIQrO/n4Iiy2vV4rIM9QxewFDy5E2ffcMpY";
    };
    doCheck = false;
  };

  pythonEnv = pkgs.python311.withPackages (ps: with ps; [
    django
    django_extensions
    django-crispy-forms
    django-crispy-bootstrap4
    pypdftk
  ]);
in
pkgs.dockerTools.buildImage {
  name = "ac2";
  tag = "dev";
  fromImage = pythonTiny;
  contents = [ 
    currentDir
    pythonEnv
    # later bash can be stripped out, but for 
    # the moment it has to be present to run the development server.
    # on production I will use nginx.
    pkgs.bash
    # PDFTK adds 1GB to the container!!!
    pkgs.pdftk
  ];
  config = {
    Cmd = [ "/bin/sh" "-c" "./startup.sh" ];    
    ExposedPorts = {
      "8000/tcp" = {};
    };
  };
}
```

- **Setting the Stage**: I start by importing `nixpkgs` to provide access to the [nix-repository](https://search.nixos.org/packages).
- **Crafting the Potion**: Then, I mix up a custom environment with Python, Django, and Crispy.
- **Customizing further**: pypdftk is not available in the Nix default set of 80.000 packages, so I had to build it specifically. Pypdftk provides the link between python commands to the PDF Toolkit.

- **Last but not least**: When in production, I'll add a step to compile all files like it was done in the base image.

Finally the container is build with:

``` bash
nix-build default.nix
```

And here there's a essential additional step not needed when using simply docker, load the container:

``` bash
docker load < result
```

Then the container must be run and the port exposed:

``` bash
sudo docker run -it -p 8000:8000 (container-name)
```

The total container size is 546MB. But with the PDFTK it goes up to 1.5GB. So maybe I'll try a different approach - there are [PDFTK containers less than 30mb in size](https://github.com/minidocks/pdftk).

## Signing Off

Choosing the right base image in Docker isn't just a technical decision; it's a strategic move in your project's journey. While NixOS brought me wisdom in control and isolation, I've found that a lighter touch might better serve the speed and adaptability my Django project needs.

So, fellow travelers, as you navigate the seas of containerization and environment configurations, keep your eyes open for the tools and choices that best fit your journey. Share your stories and learn from each other.

Until next time, keep coding and stay curious!